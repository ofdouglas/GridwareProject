# Gridware Protobuf Encoder / Decoder Project

Instructions:
1. Build the project by running the `make` command (no arguments).
2. Do a test image transfer by running `./main input.bin output.bin`, where `input.bin` is any regular file.
3. To verify the result of the test, run `diff input.bin output.bin`. The files should be identical, so that `diff` does not print any output.

Known issues:
1. The CRC is not implemented yet.
2. The device is not yet able to send a response indicating an invalid CRC. Whenever I try to encode a `DeviceResponse` packet with `verified=false`, the `pb_encode` function reports success, but writes zero bytes.
3. Retry of failed page transfers hasn't been tested at all, due to issue 2.
4. The templated helper functions in `protobuf_codec.tpp` should be generated by a script, not written by hand. The hand-written approach is OK when only have a few message types; it will become a nuisance to maintain as the number of messages increases. 

The proposed approach for code generation is for a script to extract the name of each ProtoBuf message type from the generated ProtoBuf headers, and then substitute that name into a template (non-C++ meaning) of the template helper function. For example, if we have a message called `FooMessage`, the script will transform the first set of templates below into the second set:

    //
    // Before code generation
    //
    template <>
    size_t PbMsgGetMaxMsgSize<[[[PB_MESSAGE_TYPE_NAME]]]>() { 
        return [[[PB_MESSAGE_TYPE_NAME]]]_size; 
    }

    template <>
    const pb_msgdesc_t* PbMsgGetMsgDescriptor<[[[PB_MESSAGE_TYPE_NAME]]]>() { 
        return [[[PB_MESSAGE_TYPE_NAME]]]_fields; 
    }

    //
    // After code generation
    //
    template <>
    size_t PbMsgGetMaxMsgSize<FooMessage>() { 
        return FooMessage_size; 
    }

    template <>
    const pb_msgdesc_t* PbMsgGetMsgDescriptor<FooMessage>() { 
        return FooMessage_fields; 
    }
